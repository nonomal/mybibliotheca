import os
import shutil
from datetime import datetime
from flask import Flask, session
from flask_login import LoginManager
from flask_wtf.csrf import CSRFProtect
from config import Config

# Check if Kuzu is available since it's now required
try:
    import kuzu
    from kuzu_config import kuzu_db
    from .graph_models import User, session as db_session
    KUZU_AVAILABLE = True
except ImportError as e:
    KUZU_AVAILABLE = False
    KUZU_ERROR = str(e)

# Fallback imports for SQLAlchemy (migration period only)
try:
    from sqlalchemy import inspect, text
    from .models import db, User as SQLUser
except ImportError:
    pass

login_manager = LoginManager()
csrf = CSRFProtect()

@login_manager.user_loader
def load_user(user_id):
    if not KUZU_AVAILABLE:
        raise RuntimeError("Kuzu database is required but not installed")
    return User.get(int(user_id))

def backup_database(db_path):
    """Create a backup of the database before migration"""
    if not os.path.exists(db_path):
        return None
    
    # Create backups directory if it doesn't exist
    db_dir = os.path.dirname(db_path)
    backup_dir = os.path.join(db_dir, 'backups')
    os.makedirs(backup_dir, exist_ok=True)
    
    # Create backup filename with timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    db_filename = os.path.basename(db_path)
    backup_path = os.path.join(backup_dir, f"{db_filename}.backup_{timestamp}")
    
    try:
        shutil.copy2(db_path, backup_path)
        print(f"‚úÖ Database backup created: {backup_path}")
        return backup_path
    except Exception as e:
        print(f"‚ö†Ô∏è  Failed to create database backup: {e}")
        return None

def check_if_migrations_needed(inspector):
    """Check if any migrations are needed before creating backup"""
    existing_tables = inspector.get_table_names()
    
    # Check if this is a fresh database
    if not existing_tables:
        return False, "fresh_database"
    
    migrations_needed = []
    
    # Check for missing user table
    if 'user' not in existing_tables:
        migrations_needed.append("user_table")
    
    # Check for missing columns in existing tables
    if 'book' in existing_tables:
        columns = [column['name'] for column in inspector.get_columns('book')]
        book_fields = ['user_id', 'description', 'published_date', 'page_count', 'categories', 
                      'publisher', 'language', 'average_rating', 'rating_count', 'created_at']
        missing_book_fields = [field for field in book_fields if field not in columns]
        if missing_book_fields:
            migrations_needed.append(f"book_columns: {missing_book_fields}")
    
    if 'user' in existing_tables:
        columns = [column['name'] for column in inspector.get_columns('user')]
        user_fields = ['failed_login_attempts', 'locked_until', 'last_login', 
                      'share_current_reading', 'share_reading_activity', 'share_library',
                      'reading_streak_offset']  # Add the streak offset field
        missing_user_fields = [field for field in user_fields if field not in columns]
        if missing_user_fields:
            migrations_needed.append(f"user_security_privacy: {missing_user_fields}")
    
    if 'reading_log' in existing_tables:
        columns = [column['name'] for column in inspector.get_columns('reading_log')]
        if 'user_id' not in columns or 'created_at' not in columns:
            migrations_needed.append("reading_log_fields")
    
    return len(migrations_needed) > 0, migrations_needed

def run_security_privacy_migration(inspector, db_engine):
    """Add security and privacy fields to user table"""
    if 'user' not in inspector.get_table_names():
        return  # User table doesn't exist yet
    
    try:
        columns = [column['name'] for column in inspector.get_columns('user')]
        
        # Security and privacy fields to add
        security_privacy_fields = [
            ('failed_login_attempts', 'INTEGER DEFAULT 0'),
            ('locked_until', 'DATETIME'),
            ('last_login', 'DATETIME'),
            ('share_current_reading', 'BOOLEAN DEFAULT 1'),
            ('share_reading_activity', 'BOOLEAN DEFAULT 1'),
            ('share_library', 'BOOLEAN DEFAULT 1')
        ]
        
        missing_fields = [field for field, _ in security_privacy_fields if field not in columns]
        
        if missing_fields:
            print(f"üîÑ Adding security/privacy fields: {missing_fields}")
            with db_engine.connect() as conn:
                for field_name, field_def in security_privacy_fields:
                    if field_name not in columns:
                        conn.execute(text(f"ALTER TABLE user ADD COLUMN {field_name} {field_def}"))
                        print(f"‚úÖ Added {field_name} to user table")
                conn.commit()
            print("‚úÖ Security/privacy migration completed.")
        else:
            print("‚úÖ Security/privacy fields already present.")
            
    except Exception as e:
        print(f"‚ö†Ô∏è  Security/privacy migration failed: {e}")

def add_streak_offset_column(inspector, engine):
    """Add reading_streak_offset column to users table"""
    try:
        columns = [column['name'] for column in inspector.get_columns('user')]
        if 'reading_streak_offset' not in columns:
            print("üîÑ Adding reading_streak_offset column to user table...")
            with engine.connect() as conn:
                conn.execute(text("ALTER TABLE user ADD COLUMN reading_streak_offset INTEGER DEFAULT 0"))
                conn.commit()
            print("‚úÖ reading_streak_offset column added successfully")
        else:
            print("‚úÖ reading_streak_offset column already exists")
    except Exception as e:
        print(f"‚ö†Ô∏è  Error adding reading_streak_offset column: {e}")

def assign_existing_books_to_admin():
    """Assign existing books without user_id to the admin user"""
    try:
        # Import Book model here to avoid circular imports
        from .models import Book
        
        # Find the admin user
        admin_user = User.query.filter_by(is_admin=True).first()
        if not admin_user:
            print("‚ö†Ô∏è  No admin user found, cannot assign books")
            return
        
        # Find books without user_id
        orphaned_books = Book.query.filter_by(user_id=None).all()
        if not orphaned_books:
            print("‚úÖ No orphaned books found")
            return
            
        # Assign orphaned books to admin
        for book in orphaned_books:
            book.user_id = admin_user.id
            
        db.session.commit()
        print(f"‚úÖ Assigned {len(orphaned_books)} orphaned books to admin user: {admin_user.username}")
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Failed to assign orphaned books to admin: {e}")
        db.session.rollback()

def create_app():
    # Check Kuzu availability first
    if not KUZU_AVAILABLE:
        print("\n" + "="*80)
        print("‚ùå KUZU GRAPH DATABASE REQUIRED")
        print("="*80)
        print("MyBibliotheca now requires Kuzu graph database to run.")
        print("")
        print("üöÄ Quick Setup:")
        print("  1. Run: ./setup_kuzu_migration.sh")
        print("  2. Run: ./migrate_to_kuzu.sh")
        print("  3. Restart your app")
        print("")
        print("üìñ See VENV_MIGRATION_GUIDE.md for detailed instructions")
        print("="*80)
        raise ImportError(f"Kuzu is required but not available: {KUZU_ERROR}")
    
    app = Flask(__name__)
    app.config.from_object(Config)
    app.config['SECRET_KEY'] = 'your-secret-key'

    # Initialize debug utilities
    from .debug_utils import setup_debug_logging, print_debug_banner, debug_middleware
    
    with app.app_context():
        setup_debug_logging()
        print_debug_banner()

    # Initialize extensions
    csrf.init_app(app)
    login_manager.init_app(app)
    login_manager.login_view = 'auth.login'
    login_manager.login_message = 'Please log in to access this page.'
    login_manager.login_message_category = 'info'

    # Initialize Kuzu Graph Database
    print("üîÑ Initializing Kuzu Graph Database...")
    if not kuzu_db.connect():
        print("‚ùå Failed to connect to Kuzu database")
        print("üîß Try running the migration: ./migrate_to_kuzu.sh")
        raise Exception("Failed to initialize Kuzu database")
    
    # Create schema if needed
    try:
        kuzu_db.create_schema()
        print("‚úÖ Kuzu database initialized successfully")
    except Exception as e:
        print(f"‚ö†Ô∏è Schema may already exist: {e}")
    
    # Setup middleware for user checks
    @app.before_request
    def check_kuzu_setup():
        from flask import request, redirect, url_for
        from flask_login import current_user
        from .debug_utils import debug_middleware
        
        # Run debug middleware if enabled
        debug_middleware()
        
        # Check if setup is needed (no users exist)
        if User.query().count() == 0:
            # Skip for setup route and static files
            if request.endpoint in ['auth.setup', 'static'] or (request.endpoint and request.endpoint.startswith('static')):
                return
            # Redirect to setup page
            return redirect(url_for('auth.setup'))
        
        # Skip if user is not authenticated
        if not current_user.is_authenticated:
            return
        
        # Check if user must change password
        if hasattr(current_user, 'password_must_change') and current_user.password_must_change:
            if request.endpoint != 'auth.forced_password_change':
                return redirect(url_for('auth.forced_password_change'))

    # Register blueprints
    from .routes import bp
    from .auth import auth
    from .admin import admin
    app.register_blueprint(bp)
    app.register_blueprint(auth, url_prefix='/auth')
    app.register_blueprint(admin, url_prefix='/admin')

    return app

    # Database initialization based on configuration
    if app.config.get('USE_KUZU', True):
        # Initialize Kuzu Graph Database
        print("ÔøΩ Initializing Kuzu Graph Database...")
        if not kuzu_db.connect():
            print("‚ùå Failed to connect to Kuzu database")
            raise Exception("Failed to initialize Kuzu database")
        
        # Create schema if needed
        try:
            kuzu_db.create_schema()
            print("‚úÖ Kuzu database initialized successfully")
        except Exception as e:
            print(f"‚ö†Ô∏è Schema may already exist: {e}")
        
        # Check if setup is needed
        with app.app_context():
            @app.before_request
            def check_kuzu_setup():
                from flask import request, redirect, url_for
                from flask_login import current_user
                from .debug_utils import debug_middleware
                
                # Run debug middleware if enabled
                debug_middleware()
                
                # Check if setup is needed (no users exist)
                if User.query().count() == 0:
                    # Skip for setup route and static files
                    if request.endpoint in ['auth.setup', 'static'] or (request.endpoint and request.endpoint.startswith('static')):
                        return
                    # Redirect to setup page
                    return redirect(url_for('auth.setup'))
                
                # Skip if user is not authenticated
                if not current_user.is_authenticated:
                    return
                
                # Check if user must change password
                if hasattr(current_user, 'password_must_change') and current_user.password_must_change:
                    if request.endpoint != 'auth.forced_password_change':
                        return redirect(url_for('auth.forced_password_change'))
    
    else:
        # Legacy SQLAlchemy initialization (for migration period)
        db.init_app(app)
        
        # Include existing migration logic for SQLAlchemy
        with app.app_context():
            # ... existing SQLAlchemy migration code ...
            pass

    # Register blueprints
    from .routes import bp
    from .auth import auth
    from .admin import admin
    app.register_blueprint(bp)
    app.register_blueprint(auth, url_prefix='/auth')
    app.register_blueprint(admin, url_prefix='/admin')

    return app
